---
layout: ../layouts/MainLayout.astro
title: "lipu"
source: ""
scope: "public"
type: "source"
created: "2024-08-05T15:22Z"
modified: "2024-08-21T16:37Z"
---

import NoteMeta from "../components/NoteMeta.astro"

<NoteMeta name="lipu-idea" source="" scope="public" type="main" created="2024-08-05T15:22Z" modified="2024-08-05T15:28Z" />

I want a single app that would replace newpipe, antennapod and an rss reader. So basically an *RSS reader*/downloader plus *video/audio player*.

Initially I wanted to build it for Android, but I also want it to work on my computer, so I'll use a cross-platform framework.

It must be local-first, everything gets downloaded, everything works offline.

---

<NoteMeta name="lipu-motivation" source="" scope="public" type="main" created="2024-08-05T15:32Z" modified="2024-08-15T14:51Z" />

I [wanted an RSS reader](/read-important-things-deeply), *miniflux* looks like a good option, but it's unnecesserally *complicated* for my use-case, it has a server and a client and I *don't want/need a server*. Plus it's *fun to build* things!

---

<NoteMeta name="lipu-lifecycle" source="" scope="public" type="main" created="2024-08-05T15:28Z" modified="2024-08-09T13:58Z" />

The *first version* will be just a *CLI*, to test out the idea.

Then it needs a *frontend*, I think [tauri](/tauri) looks good.

Then it needs ompl support and, as it turns out, youtube downloads.

---

<NoteMeta name="rust-rss-crate" source="https://docs.rs/rss/latest/rss/" scope="public" type="main" created="2024-08-05T16:03Z" modified="2024-08-07T13:48Z" />

A crate for reading/*creating* rss feeds. See [feed-rs](/feed-rs) as well.
```shell
> cargo add rss
```
```rust
use rss::Channel;
use rss::ChannelBuilder;

fn read() -> Channel {
    let file = std::fs::File::open("feed.xml").unwrap();
    let buffer = std::io::BufReader::new(file);
    Channel::read_from(buffer).unwrap()
}

fn create() -> Channel {
    ChannelBuilder::default()
        .title("Example feed")
        .link("http://example.com/feed")
        .description("Test feed")
        .build()
}
```

Channel has its metadata and `items`:
```rust
struct Item {
    title: Option<String>,
    link: Option<String>,
    description: Option<String>,
    author: Option<String>,
    categories: Vec<Category>,
    comments: Option<String>,
    /// The description of a media object that is attached to the item.
    enclosure: Option<Enclosure>,
    guid: Option<Guid>,
    pub_date: Option<String>,
    /// The RSS channel the item came from.
    source: Option<Source>,
    /// The HTML contents of the item.
    content: Option<String>,
    extensions: ExtensionMap,
    atom_ext: Option<atom::AtomExtension>,
    itunes_ext: Option<itunes::ITunesItemExtension>,
    // some fields omitted
}
```

---

<NoteMeta name="goal-for-2024-08-07" source="" scope="public" type="main" created="2024-08-07T08:27Z" modified="2024-08-07T09:43Z" />

Today I want to make a functioning prototype in the CLI.

---

<NoteMeta name="rust-reqwest-crate" source="https://docs.rs/reqwest/latest/reqwest/" scope="public" type="main" created="2024-08-07T10:06Z" modified="2024-08-07T10:13Z" />

*reqwest* is the rust's most popular HTTP client:
```toml
# add to Cargo.toml
reqwest = {
    version = "0.12.5",
    features = ["rustls-tls", "json"], # don't use OS's openssl
    default-features = false,
}
```
```rust
let body = reqwest::get("https://example.com")
    .await?
    .text()
    .await()?;

let response = reqwest::Client::new()
    .post("http://httpbin.org/post")
    .json(&some_hashmap_here)
    .send()
    .await?;
```

---

*not created yet*

---

<NoteMeta name="lipu-oopsie" source="" scope="public" type="main" created="2024-08-07T13:49Z" modified="2024-08-07T13:52Z" />

I've tried to use the [rust-rss-crate](/rust-rss-crate) for the project because it's the only one I've heared of. Everything worked fine until I *tried adding more feeds*. I tested it with [fasterthanlime's feed](https://fasterthanli.me/index.xml) and [namtao's youtube feed](https://www.youtube.com/feeds/videos.xml?channel_id=UCMHZ1P2iYimObhtHKfPz7gw). The library complained that the feeds didn't have a correct rss version.

So now I'm rewriting the entire thing (which is thankfully very small, so it's not a big deal) to use [feed-rs](/feed-rs).

---

<NoteMeta name="feed-rs" source="https://docs.rs/feed-rs/2.1.0/feed_rs/index.html" scope="public" type="main" created="2024-08-07T12:50Z" modified="2024-08-07T13:49Z" />

A crate for reading rss, atom, json feeds.

It has much more *comprehensive types* and supports more formats than the [rust-rss-crate](/rust-rss-crate).

```rust
let feed = parser::parse(xml.as_bytes()).unwrap();
```

---

*not created yet*

---

<NoteMeta name="no-videos-though" source="" scope="public" type="main" created="2024-08-07T14:13Z" modified="2024-08-07T14:19Z" />

I've fixed the previous error, added the No Boilerplate feed, ran the app. It errored out.

Turns out it's not that simple to download things from youtube.

Let's pray that [yt-dlp](/yt-dlp) is written in rust and has a library.

\*checks\*

\*dies\*

And things like youtube-cli are wrappers on top of yt-dlp, so that doesn't help either. I don't want this project to have any system-level dependencies!

---

<NoteMeta name="no-videos-solution-0" source="" scope="public" type="main" created="2024-08-07T14:18Z" modified="2024-08-07T14:21Z" />

I've just realized that I can use iframes. So the simplest, *dumbest solution that will work* is to add an *ArticleBody::YouTube* enum variant, have it be a link and read it in the front-end.

---

<NoteMeta name="no-videos-solution-1" source="" scope="public" type="main" created="2024-08-07T14:22Z" modified="2024-08-08T08:19Z" />

After some more ~~googling~~ (duckduckgoing?) I have found the [rusty_ytdl](/rusty_ytdl) crate. I've not found it the first time because it's just a library, with no front-end ~~or apparently I'm just blind~~.

Anyway, I think it's *worth implementing both* because youtube may break something on their end, rendering the [rusty_ytdl](/rusty_ytdl) useless.

Though it makes sense to *start with the [option 0](/no-videos-solution-0)* because it's more lightweight.

---

<NoteMeta name="lipu-library" source="" scope="public" type="main" created="2024-08-08T07:55Z" modified="2024-08-08T08:03Z" />

The logic part of [lipu](/lipu), rss reader back-end.

Usage:
```rust
use lipu::App;

// App is just a builder to get Vec<Article>
let app: App = App::new().add_feed("https://fasterthanli.me/index.xml");
let articles: Vec<Article> = app.fetch().await;
```

A [CLI app exmaple](https://github.com/janElikan/lipu/blob/main/src/main.rs).

Types:
```rust
pub struct Article {
    pub id: String,
    pub name: String,
    pub source: Option<String>,
    pub description: Option<String>,
    pub body: ArticleBody,
    pub created: Option<DateTime<Utc>>,
    pub updated: Option<DateTime<Utc>>,
    pub viewed: Progress,
}

pub enum ArticleBody {
    Text(String),
    Video(MediaPayload),
    Audio(MediaPayload),
    YouTubeLink(String),
}

pub enum Progress {
    None,
    UntilLine(usize),
    UntilSecond(usize),
    Fully,
}

pub struct MediaPayload {
    pub url: String,
    pub mime_type: String,
    pub downloaded: bool,
}
```

---

<NoteMeta name="tauri-the-framework" source="https://v2.tauri.app/start/" scope="public" type="main" created="2024-08-09T13:49Z" modified="2024-08-09T15:23Z" />

Tauri is a *cross-platform GUI* framework that uses [html](/html), [css](/css) and [javascript](/javascript) as a frontend and [rust](/rust) as a backend.

What makes it *different* from something like [electron](/electron) is that it *uses system webview* instead of depending on chromium.

As a result,
- The apps are small
- It *feels fast*

---

<NoteMeta name="tauri-install" source="https://tauri.app/v1/guides/getting-started/prerequisites/#1-system-dependencies" scope="public" type="main" created="2024-08-09T13:57Z" modified="2024-08-10T13:08Z" />

Install the [system deps](https://v2.tauri.app/start/prerequisites/#system-dependencies). If you're on [nixos](/nixos), I have [made a flake](https://gist.github.com/janElikan/1a0d66b7f059387e44ba232b79af7450).

```shell
> npm create tauri-app@latest -- --rc
> cd <name>
> npm install
> npm run tauri android init
> npm run tauri dev
# or npm run tauri android dev
```

When using git, you *should commit* `Cargo.toml`, `Cargo.lock` and, if you are using, them `flake.nix` and `flake.lock`.

---

<NoteMeta name="sidenote-tauri-android" source="" scope="public" type="main" created="2024-08-09T17:28Z" modified="2024-08-09T19:56Z" />

```
[elikan@suli:/nix/persist/repos/tauri-playground/tauri-app]$ npm run tauri android init

> tauri-app@0.0.0 tauri
> tauri android init

Generating Android Studio project...
    Info "/nix/persist/repos/tauri-playground/tauri-app/src-tauri" relative to "/nix/persist/repos/tauri-playground/tauri-app/src-tauri/gen/android/tauri_app" is "../../../"
victory: Project generated successfully!
    Make cool apps! 🌻 🐕 🎉
```

Victory indeed, considering that I've spent the last 128 minutes trying to get it to work!

oh wait, I forgot something:
```
Please set the JAVA_HOME variable in your environment to match the
location of your Java installation.

    Error Failed to assemble APK: command ["/nix/persist/repos/tauri-playground/tauri-app/src-tauri/gen/android/gradlew", "--project-dir", "/nix/persist/repos/tauri-playground/tauri-app/src-tauri/gen/android"] exited with code 1: command ["/nix/persist/repos/tauri-playground/tauri-app/src-tauri/gen/android/gradlew", "--project-dir", "/nix/persist/repos/tauri-playground/tauri-app/src-tauri/gen/android"] exited with code 1
```

Fixed that, ran it again and now it hang. I think it's okay, that's probably gradle being slow (?)

I'm not very good with ~~plants~~ android and java tooling.

```
* What went wrong:
Could not determine the dependencies of task ':app:compileArm64DebugJavaWithJavac'.
> Failed to install the following SDK components:
      platforms;android-34 Android SDK Platform 34
  The SDK directory is not writable (/nix/store/ag3w2qik8hwb7wbf0bdxdwfjx3z0akd6-androidsdk/libexec/android-sdk)
```

(error about `aapt2` omitted)

now I need [dynamic linking](https://github.com/0atman/noboilerplate/blob/main/scripts/38-nixos.md#ld-fix)... Oh, wait, [no I don't, it's just the dependencies](https://nixos.wiki/wiki/Android#gradlew)

Finally! I'll publish the gist on 2024-08-10

---

<NoteMeta name="lipu-todos" source="" scope="public" type="main" created="2024-08-13T09:54Z" modified="2024-08-14T13:45Z" />

- back end: add link tag support (see 0atman's feed)
- frontend: add full screen video view
- both: add better support for dialogs (like the ones [fasterthanlime](https://fasterthanli.me) and [Xe Iaso](https://xeiaso.net) use)

---

<NoteMeta name="lipu-status-day-6" source="" scope="public" type="main" created="2024-08-13T10:57Z" modified="2024-08-13T11:03Z" />

- [x] tauri setup
- [x] list download
- [x] list view
- [x] light mode
- [x] app controls (except the buttons shift sometimes)
- [ ] app control logic
- [ ] article view
- [ ] audio view
- [ ] media download
- [ ] youtube view
- [ ] video view
- [ ] progress saving
- [ ] settings & feeds
- [ ] desktop shortcuts

---

<NoteMeta name="note-on-languages" source="" scope="public" type="main" created="2024-08-14T13:59Z" modified="2024-08-14T14:01Z" />

I've noticed a drastic difference between writing the back-end and the front-end for [lipu](/lipu).

The front-end currently uses [react](/react), I run the app continuously and click around to make sure nothing breaks (it does).

The back-end was written in [rust](/rust), I ran it like twice to make sure the thing does everything I want it to. The rest of the time I just had [cargo-clippy](/cargo-clippy) on the right half of the screen and "talked" to it.

*The rust experience really is nicer.*

---

<NoteMeta name="note-on-lipu-day-7" source="" scope="public" type="main" created="2024-08-14T15:03Z" modified="2024-08-14T15:23Z" />

I *don't love how cards look*, probably gonna get rid of them in a few days.

Also, while I remember, the plan is to eventually *scrape* the website that an article is coming from *if it's allowed* by its `robots.txt`.

I should *tweak the backend* so that if an *item disappears* from the feed (Xe's feed is just the last 10 articles, for example), it should be *kept on the device*.

And the back button doesn't work on mobile because it's a single-page app and I don't catch that event.

And add the zoom for images.

---

<NoteMeta name="lipu-groups" source="" scope="public" type="main" created="2024-08-15T14:41Z" modified="2024-08-15T14:47Z" />

I need to *remember to add folders/groups*.

Context: I have discovered that a service we use at *work has an RSS feed*. I don't want to mix the blogs I'm reading with work, so this. Also iirc *mastodon gives you feeds*, it'd be useful for that as well.

---

<NoteMeta name="lipu-cookies" source="" scope="public" type="main" created="2024-08-15T14:47Z" modified="2024-08-15T14:48Z" />

Some RSS feeds require you to log in, so the app needs an interface to do that. Should be relatively simple considering the front-end is a webapp and I can just add an iframe with the login form, then pull the cookies to the back-end.

---

<NoteMeta name="rethinking-lipu" source="" scope="public" type="main" created="2024-08-17T16:16Z" modified="2024-08-17T18:16Z" />

Back-end:

| task                             | component                  |
| -------------------------------- | -------------------------- |
| managing feeds                   | lib                        |
| fetching updates                 | lib                        |
| managing groups                  | lib                        |
| downloading media                | lib, path provided by main |
| keeping track of user's progress | lib                        |
| managing what's playing now      | main                       |

Front-end:

| task                                                 | component      |
| ---------------------------------------------------- | -------------- |
| rendering the list of feed items                     | List           |
| rendering the list of groups                         | Groups         |
| rendering a feed item's description or text body     | Item           |
| playing media in the foreground and background       | Player         |
| controlling media, sending its state to the back-end | PlayerControls |

---

<NoteMeta name="lipu-new-types" source="" scope="public" type="main" created="2024-08-17T18:09Z" modified="2024-08-17T18:14Z" />

```rust
pub struct Lipu {
    feeds: Vec<String>,
    items: Vec<Item>,
}

trait LipuInterface {
    fn add_feed(&mut self, url: String);
    fn add_mastodon_feed(&mut self, instance: String, user: String);
    async fn add_youtube_channel(&mut self, name: String);
    async fn refresh(&mut self) -> Result<(), ()>;
    fn remove_feed(&mut self, url: &str) -> Result<(), ()>;

    fn list(&self) -> &[Metadata];
    fn search(&self, query: &str) -> &[Metadata];
    fn with_tag(&self) -> &[Metadata];

    fn add_tag(&mut self, item_id: &str, tag: &str) -> Result<(), ()>;
    fn remove_tag(&mut self, item_id: &str, tag: &str) -> Result<(), ()>;
    fn drop_tag(&mut self, tag: &str) -> Result<(), ()>;

    fn load(&self, item_id: &str) -> &Item;
    fn set_viewing_progress(&mut self, item_id: &str, progress: ViewingProgress) -> Result<(), ()>;
    async fn download_item(&mut self, item_id: &str) -> Result<(), ()>;
}
```
This interface does everything that I have outlined [above](/rethinking-lipu), I think. The frontend's job from here is to handle the playback and rendering.

```rust
pub struct Item {
    pub metadata: Metadata,
    pub body: Body,
}

pub struct Metadata {
    pub id: String,

    pub name: String,
    pub tags: Vec<String>,

    pub feed_url: String,
    pub link: Option<String>,
    pub author: Option<String>,
    pub description: Option<String>,

    pub created: Option<DateTime<Utc>>,
    pub updated: Option<DateTime<Utc>>,

    pub viewed: ViewingProgress,
}

pub enum ViewingProgress {
    Zero,
    UntilParagraph(usize),
    UntilSecond(usize),
    Fully,
}

pub enum Body {
    DownloadLink { mime_type: String, url: String },
    File { mime_type: String, path: PathBuf },
}
```
This new `Body` will contain *text as files* as well, because some feeds don't give you a *full article*, so it *will have to be downloaded* from the website. *Lipu is a reader, not just a list of links.*

---

<NoteMeta name="lipu-new-types-implemented" source="" scope="public" type="main" created="2024-08-18T11:34Z" modified="2024-08-18T11:36Z" />

I believe [it is implemented now](https://github.com/janElikan/lipu/tree/c2f4e6a2a1b093fa2bc474c92a4399f0d673a27e), or at least a minimal version of it. Clippy is not happy, but what I want right now is a *working prototype*, which I can refactor later. So I'm switching over to the front-end side of things.

---

<NoteMeta name="lipu-no-more-react" source="" scope="public" type="main" created="2024-08-19T16:49Z" modified="2024-08-19T16:50Z" />

I have moved the search logic to the back-end, thinking that react was slow. Now it is still just as slow. I'll try switching to vanilla to see if that fixes anything.

---

<NoteMeta name="lipu-startup-as-conversation" source="" scope="public" type="main" created="2024-08-20T21:27Z" modified="2024-08-21T16:36Z" />

main.ts: await Dom load
window: done
main: init feeds
main: init items
main: init reader
main: init player
feeds: window find element feeds
items: window find element items
player: window init
reader: window init
player: done
reader: done
window: div#feeds
window: div#items
feeds: backend fetch feeds
items: backend refresh
items: window draw refreshing animation
backend: *feed list*
feeds: window render this
feeds: done
backend: *OK*
items: backend list
backend: *metadata*
items: window render this
items: done

window: button clicked *ID*
list: main what is this *ID*
main: backend load *ID*
backend: *body*
main: looks like a podcast
main: player, *body*
main: reader, *metadata*
player: window, update
reader: window, rerender